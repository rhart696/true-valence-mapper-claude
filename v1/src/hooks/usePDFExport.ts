'use client';

import { useCallback, useState } from 'react';
import type { Relationship } from '../types';

interface UsePDFExportReturn {
  isExporting: boolean;
  exportPDF: (canvasElementId: string, relationships?: Relationship[]) => Promise<void>;
}

export function usePDFExport(): UsePDFExportReturn {
  const [isExporting, setIsExporting] = useState(false);

  const exportPDF = useCallback(async (canvasElementId: string, relationships?: Relationship[]) => {
    setIsExporting(true);
    try {
      const jsPDF = (await import('jspdf')).default;

      const svgEl = document.getElementById(canvasElementId) as SVGSVGElement | null;
      if (!svgEl) throw new Error(`Element #${canvasElementId} not found`);

      // Serialize SVG → canvas → PNG (bypasses html2canvas cloned-iframe limitation)
      const serialized = new XMLSerializer().serializeToString(svgEl);
      const svgBlob = new Blob([serialized], { type: 'image/svg+xml;charset=utf-8' });
      const svgUrl = URL.createObjectURL(svgBlob);

      const SCALE = 2;
      // Use viewBox dimensions for pixel-perfect rendering at any display size
      const vb = svgEl.viewBox.baseVal;
      const canvasW = (vb.width || 900) * SCALE;
      const canvasH = (vb.height || 700) * SCALE;

      const img = await new Promise<HTMLImageElement>((resolve, reject) => {
        const i = new Image();
        i.onload = () => resolve(i);
        i.onerror = reject;
        i.src = svgUrl;
      });

      const canvas = document.createElement('canvas');
      canvas.width = canvasW;
      canvas.height = canvasH;
      const ctx = canvas.getContext('2d')!;
      ctx.drawImage(img, 0, 0, canvasW, canvasH);
      URL.revokeObjectURL(svgUrl);

      const imgData = canvas.toDataURL('image/png');

      const pdf = new jsPDF('landscape', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();

      // Header
      pdf.setFontSize(20);
      pdf.text('Trust Mapping Session', pageWidth / 2, 15, { align: 'center' });
      pdf.setFontSize(10);
      pdf.text(new Date().toLocaleDateString(), pageWidth / 2, 22, { align: 'center' });

      // Map image (fills page minus header/footer margins)
      const imgWidth = pageWidth - 20;
      const imgHeight = (canvasH * imgWidth) / canvasW;
      const maxImgHeight = pageHeight - 45;
      const finalHeight = Math.min(imgHeight, maxImgHeight);
      const finalWidth = (canvasW * finalHeight) / canvasH;

      pdf.addImage(imgData, 'PNG', (pageWidth - finalWidth) / 2, 28, finalWidth, finalHeight);

      // Footer
      pdf.setFontSize(8);
      pdf.text('Generated by True Valence Mapper', pageWidth / 2, pageHeight - 5, { align: 'center' });

      // Notes page — only when at least one relationship has a non-empty note
      const noteRels = (relationships ?? []).filter((r) => r.note?.trim());
      if (noteRels.length > 0) {
        pdf.addPage();
        pdf.setFontSize(14);
        pdf.text('Session Notes', 14, 18);
        pdf.setFontSize(10);
        let y = 30;
        for (const r of noteRels) {
          const lines = pdf.splitTextToSize(`${r.name} — ${r.note}`, pageWidth - 28);
          pdf.text(lines, 14, y);
          y += lines.length * 6 + 4;
          if (y > pageHeight - 20) { pdf.addPage(); y = 20; }
        }
      }

      const dateStr = new Date().toISOString().split('T')[0];
      pdf.save(`trust-map-${dateStr}.pdf`);
    } catch (error) {
      console.error('PDF export failed:', error);
      // Fallback: browser print dialog
      window.print();
    } finally {
      setIsExporting(false);
    }
  }, []);

  return { isExporting, exportPDF };
}
