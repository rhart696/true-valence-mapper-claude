'use client';

import { useCallback, useState } from 'react';
import type { Relationship } from '../types';

interface UsePDFExportReturn {
  isExporting: boolean;
  exportPDF: (canvasElementId: string, relationships?: Relationship[], coacheeName?: string) => Promise<void>;
  exportPNG: (canvasElementId: string, coacheeName?: string) => Promise<void>;
}

/** Serialise SVG element → offscreen canvas → PNG data URL. */
async function svgToImageData(
  canvasElementId: string,
  scale: number,
  footerText?: string,
): Promise<{ imgData: string; canvasW: number; canvasH: number } | null> {
  const svgEl = document.getElementById(canvasElementId) as SVGSVGElement | null;
  if (!svgEl) return null;

  const serialized = new XMLSerializer().serializeToString(svgEl);
  const svgBlob = new Blob([serialized], { type: 'image/svg+xml;charset=utf-8' });
  const svgUrl = URL.createObjectURL(svgBlob);

  const vb = svgEl.viewBox.baseVal;
  const canvasW = (vb.width || 900) * scale;
  const canvasH = (vb.height || 700) * scale;

  const img = await new Promise<HTMLImageElement>((resolve, reject) => {
    const i = new Image();
    i.onload = () => resolve(i);
    i.onerror = reject;
    i.src = svgUrl;
  });

  const canvas = document.createElement('canvas');
  canvas.width = canvasW;
  canvas.height = canvasH;
  const ctx = canvas.getContext('2d')!;
  ctx.drawImage(img, 0, 0, canvasW, canvasH);
  URL.revokeObjectURL(svgUrl);

  if (footerText) {
    const fontSize = Math.round(11 * scale);
    ctx.font = `${fontSize}px Inter, -apple-system, BlinkMacSystemFont, sans-serif`;
    ctx.fillStyle = 'rgba(107, 119, 140, 0.8)';
    ctx.textAlign = 'right';
    ctx.fillText(footerText, canvasW - 12 * scale, canvasH - 10 * scale);
  }

  return { imgData: canvas.toDataURL('image/png'), canvasW, canvasH };
}

/** Produce a URL-safe slug prefix from the coachee name, e.g. "sarah-" or "". */
function filePrefix(coacheeName?: string): string {
  const trimmed = coacheeName?.trim();
  if (!trimmed) return '';
  return trimmed.toLowerCase().replace(/[^a-z0-9]+/g, '-') + '-';
}

export function usePDFExport(): UsePDFExportReturn {
  const [isExporting, setIsExporting] = useState(false);

  const exportPDF = useCallback(async (canvasElementId: string, relationships?: Relationship[], coacheeName?: string) => {
    setIsExporting(true);
    try {
      const jsPDF = (await import('jspdf')).default;

      // SVG → canvas (scale 2× for PDF quality)
      const result = await svgToImageData(canvasElementId, 2);
      if (!result) throw new Error(`Element #${canvasElementId} not found`);
      const { imgData, canvasW, canvasH } = result;

      const pdf = new jsPDF('landscape', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();

      // Header
      const title = coacheeName?.trim()
        ? `${coacheeName.trim()}'s Trust Map`
        : 'Trust Mapping Session';
      pdf.setFontSize(20);
      pdf.text(title, pageWidth / 2, 15, { align: 'center' });
      pdf.setFontSize(10);
      pdf.text(new Date().toLocaleDateString(), pageWidth / 2, 22, { align: 'center' });

      // Map image (fills page minus header/footer margins)
      const imgWidth = pageWidth - 20;
      const imgHeight = (canvasH * imgWidth) / canvasW;
      const maxImgHeight = pageHeight - 45;
      const finalHeight = Math.min(imgHeight, maxImgHeight);
      const finalWidth = (canvasW * finalHeight) / canvasH;

      pdf.addImage(imgData, 'PNG', (pageWidth - finalWidth) / 2, 28, finalWidth, finalHeight);

      // Notes page — only when at least one relationship has a non-empty note
      const noteRels = (relationships ?? []).filter((r) => r.note?.trim());

      // Footer
      pdf.setFontSize(8);
      pdf.text('Generated by True Valence Relationship Mapper', pageWidth / 2, pageHeight - 5, { align: 'center' });
      if (noteRels.length > 0) {
        pdf.text('Session notes: see page 2', pageWidth - 14, pageHeight - 5, { align: 'right' });
      }
      if (noteRels.length > 0) {
        pdf.addPage();
        pdf.setFontSize(14);
        pdf.text('Session Notes', 14, 18);
        pdf.setFontSize(10);
        let y = 30;
        for (const r of noteRels) {
          const lines = pdf.splitTextToSize(`${r.name} — ${r.note}`, pageWidth - 28);
          pdf.text(lines, 14, y);
          y += lines.length * 6 + 4;
          if (y > pageHeight - 20) { pdf.addPage(); y = 20; }
        }
      }

      const dateStr = new Date().toISOString().split('T')[0];
      pdf.save(`${filePrefix(coacheeName)}trust-map-${dateStr}.pdf`);
    } catch (error) {
      console.error('PDF export failed:', error);
      // Fallback: browser print dialog
      window.print();
    } finally {
      setIsExporting(false);
    }
  }, []);

  const exportPNG = useCallback(async (canvasElementId: string, coacheeName?: string) => {
    setIsExporting(true);
    try {
      // Scale 3× for a crisp PNG suitable for slide decks
      const dateStr = new Date().toISOString().split('T')[0];
      const result = await svgToImageData(canvasElementId, 3, new Date().toLocaleDateString());
      if (!result) throw new Error(`Element #${canvasElementId} not found`);
      const link = document.createElement('a');
      link.download = `${filePrefix(coacheeName)}trust-map-${dateStr}.png`;
      link.href = result.imgData;
      link.click();
    } catch (error) {
      console.error('PNG export failed:', error);
    } finally {
      setIsExporting(false);
    }
  }, []);

  return { isExporting, exportPDF, exportPNG };
}
